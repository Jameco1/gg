<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Teachable Machine MQTT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest"></script>

  <!-- MQTT.js -->
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    video { border: 3px solid #333; border-radius: 10px; width: 320px; height: 240px; }
    #status { margin-top: 15px; font-weight: bold; color: red; }
  </style>
</head>
<body>
  <h1>üé• Teachable Machine + MQTT</h1>
  <video id="webcam" autoplay playsinline></video>
  <p id="status">‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á...</p>

  <script type="text/javascript">
    const URL = "https://teachablemachine.withgoogle.com/models/xxxxxxx/"; // üëà ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô model ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    let model, webcam, ctx, labelContainer, maxPredictions;

    // MQTT client ‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß (1883 ‡πÅ‡∏•‡∏∞ 8884)
    const broker = "broker.hivemq.com";
    const topicESP32 = "real2";   // ESP32
    const topicHive = "realHive"; // HiveMQTT

    // Connect MQTT (1883 = WebSocket, 8884 = Secure WebSocket)
    const client1883 = mqtt.connect(`wss://${broker}:8083/mqtt`);
    const client8884 = mqtt.connect(`wss://${broker}:8884/mqtt`);

    client1883.on("connect", () => console.log("‚úÖ Connected to MQTT 1883"));
    client8884.on("connect", () => console.log("‚úÖ Connected to MQTT 8884"));

    async function init() {
      try {
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";

        // ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();

        // ‡∏Ç‡∏≠‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡∏•‡πâ‡∏≠‡∏á
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        document.getElementById("status").innerText = "‚úÖ ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß";
        const webcamElement = document.getElementById("webcam");
        webcamElement.srcObject = stream;

        // loop ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
        setInterval(() => predict(webcamElement), 2000);

      } catch (err) {
        console.error("‚ùå Camera error:", err);
        document.getElementById("status").innerText =
          "‚ùå ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: " + err.message;
      }
    }

    async function predict(video) {
      const prediction = await model.predict(video);
      let best = prediction[0];

      // ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
      for (let i = 1; i < prediction.length; i++) {
        if (prediction[i].probability > best.probability) {
          best = prediction[i];
        }
      }

      console.log("üìå ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:", best.className, best.probability.toFixed(2));

      // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏™‡πà‡∏á MQTT ‡πÅ‡∏¢‡∏Å port
      if (best.className === "circle") {
        client8884.publish(topicHive, "circle");
        console.log("‚û°Ô∏è ‡∏™‡πà‡∏á‡πÑ‡∏õ HiveMQTT (8884): circle");
      } else if (best.className === "square") {
        client1883.publish(topicESP32, "square");
        console.log("‚û°Ô∏è ‡∏™‡πà‡∏á‡πÑ‡∏õ ESP32 (1883): square");
      }
    }

    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö
    init();
  </script>
</body>
</html>

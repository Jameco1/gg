<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>Shapes → MQTT Dual-Port (GitHub Ready)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
<style>
body{margin:0;font-family:sans-serif;background:#0b1020;color:#e5e7eb;display:flex;flex-direction:column;align-items:center}
button{padding:10px 14px;margin:5px;border-radius:8px;background:#111827;color:#fff;cursor:pointer}
#webcam-container canvas{border-radius:12px;border:2px solid rgba(255,255,255,0.06);max-width:640px;width:100%;}
.log{height:200px;overflow:auto;background:#11172a;border-radius:12px;padding:8px;font:12px monospace;width:100%;max-width:700px;margin-top:10px;}
</style>
</head>
<body>

<h1>Teachable Machine Shapes → MQTT Dual-Port</h1>
<p>คลิกปุ่ม Start เพื่อเปิดกล้องและเริ่มทำนาย</p>
<button onclick="startAll('environment')">Start Back Cam</button>
<button onclick="startAll('user')">Start Front Cam</button>
<button onclick="stopAll()">Stop</button>
<div id="webcam-container"></div>
<div class="log" id="log"></div>

<script>
const TM_URL = "https://teachablemachine.withgoogle.com/models/ahaxFn-GG/";
const MQTT_TOPIC = "Opzaa1";
const CONF_THRESHOLD = 0.8;
const PUBLISH_DEBOUNCE_MS = 2500;

// HiveMQ SSL 8884
const MQTT_HOST_SSL = "broker.hivemq.com", MQTT_PORT_SSL = 8884, MQTT_PATH_SSL="/mqtt";
// ESP32 WS 8000
const MQTT_HOST_ESP = "broker.hivemq.com", MQTT_PORT_ESP=8000, MQTT_PATH_ESP="/mqtt";

// UI
const logEl = document.getElementById('log');
const log = (...args)=>{ const d=document.createElement('div'); d.textContent=args.join(' '); logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight; console.log(...args); };

// MQTT Clients
let mqttSSL=null, mqttESP=null, clientIdSSL=null, clientIdESP=null;
async function connectMQTT(){
  return new Promise((resolve)=>{
    // HiveMQ SSL
    clientIdSSL = "web_ssl_"+Math.floor(Math.random()*1e6);
    mqttSSL = new Paho.MQTT.Client(MQTT_HOST_SSL, MQTT_PORT_SSL, MQTT_PATH_SSL, clientIdSSL);
    mqttSSL.onConnectionLost = resp=>log("HiveMQ lost", resp?.errorMessage||"");
    mqttSSL.onMessageArrived = msg=>log("RX SSL", msg.destinationName, msg.payloadString);
    mqttSSL.connect({useSSL:true, timeout:20, onSuccess:()=>log("HiveMQ connected"), onFailure:e=>log("HiveMQ failed", e)});

    // ESP32 WS
    clientIdESP = "web_esp_"+Math.floor(Math.random()*1e6);
    mqttESP = new Paho.MQTT.Client(MQTT_HOST_ESP, MQTT_PORT_ESP, MQTT_PATH_ESP, clientIdESP);
    mqttESP.onConnectionLost = resp=>log("ESP32 lost", resp?.errorMessage||"");
    mqttESP.onMessageArrived = msg=>log("RX ESP", msg.destinationName, msg.payloadString);
    mqttESP.connect({useSSL:false, timeout:20, onSuccess:()=>log("ESP32 connected"), onFailure:e=>log("ESP32 failed", e)});
    resolve();
  });
}

function safePublishSSL(msg){ if(mqttSSL&&mqttSSL.isConnected()) mqttSSL.send(new Paho.MQTT.Message(msg)); }
function safePublishESP(msg){ if(mqttESP&&mqttESP.isConnected()) mqttESP.send(new Paho.MQTT.Message(msg)); }

function publishDual(shape){
  if(shape==='วงกลม'||shape==='Circle'){ safePublishSSL(shape); safePublishESP(shape); log("Publish dual:",shape); }
  else if(shape==='สามเหลี่ยม'||shape==='Triangle'){ safePublishESP(shape); log("Publish ESP only:",shape); }
  else if(shape==='สี่เหลี่ยม'||shape==='Square'){ safePublishESP(shape); log("Publish ESP only:",shape); }
}

// Teachable Machine
let model, webcam, maxPredictions, lastSentAt=0, running=false;
async function loadModel(){
  log("Loading model...");
  model = await tmImage.load(TM_URL+'model.json', TM_URL+'metadata.json');
  maxPredictions = model.getTotalClasses();
  log("Model loaded:", maxPredictions,"classes");
}

async function startCamera(facingMode){
  webcam = new tmImage.Webcam(320,320,false);
  await webcam.setup({facingMode}); // ต้อง await
  await webcam.play();
  document.getElementById('webcam-container').innerHTML='';
  document.getElementById('webcam-container').appendChild(webcam.canvas);
  log("Camera streaming:", facingMode);
}

async function predictLoop(){
  if(!running) return;
  webcam.update();
  const preds = await model.predict(webcam.canvas);
  let best = preds.reduce((a,b)=>b.probability>a.probability?b:a);
  const now = Date.now();
  if(best.probability>=CONF_THRESHOLD && now-lastSentAt>=PUBLISH_DEBOUNCE_MS){
    lastSentAt = now;
    publishDual(best.className);
  }
  requestAnimationFrame(predictLoop);
}

async function startAll(facing){
  running=false;
  await connectMQTT();
  await loadModel();
  await startCamera(facing);
  running=true;
  predictLoop();
}

function stopAll(){ running=false; try{webcam.stop()}catch{}; document.getElementById('webcam-container').innerHTML=''; log("Stopped"); }

</script>
</body>
</html>
